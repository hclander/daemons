#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdbool.h>
#include <errno.h>
#include <getopt.h>
#include <signal.h>
#include <time.h>

// includes for socket

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include "lib/log.h"
#include "lib/hashinttable.h"
#include "frames.h"
#include "mydb.h"

#define UDP_DEFAULT_PORT 4490
#define ACK_TIMEOUT_SECS 120   // Ack Timeout in seconds

#define DB_TIMEOUT_SECS 300   // DATA BASE ACCESS TIMEOUT

int udpPort =UDP_DEFAULT_PORT;
int verboseLevel= 1;
bool keepAsDaemon=true;
bool terminate = false;

const char *TAG="RXd";

void help() {
  printf("rxd v1.0 Daemon de recepcion de tramas\n\n"
		 "Syntaxis:\n"
		 "\n\trxd [ -h | --help ] [ -p | --port <udp_port> ] [ -v | --verbose  < 0 | 1 | 2 > ]  \n"
		 "\n\twhere:\n"
		 "\t -h | --help     : Shows this help.\n"
		 "\t -p | --port     : UDP port to listen.\n"
		 "\t -v | --verbose  : Sets the verbose level( 0 Error , 1 Notice, 2  Debug )\n"
	);
}



void parseArgs(int argc, char **argv) {

	 bool noArgs    = true;
	 static struct option longOptions[] = {
	    		{"help",0,0,'h'},
	    		{"port",1,0,'p'},
	    		{"verbose",1,0,'v'},
	    		{0,0,0,0}
	    };

		//Parseo de parametros;
	    int c;

	    while ( (c = getopt_long(argc,argv,"hp:v:n",longOptions,NULL)) != -1) {

	    	if (noArgs)
	    		noArgs = false;

	    	switch(c) {
				case 'p':
					udpPort = atoi(optarg);
					break;
				case 'v':
					verboseLevel = atoi(optarg);
					break;
				case 'n':
					keepAsDaemon = false;
					break;
				default:
					help();
					exit(EXIT_FAILURE);
	    	}
	    }

	    if (noArgs) {
	    	help();
	    	exit(EXIT_FAILURE);
	    }
}

void initLogs() {

	INITLOG(TAG);
	// Para desactivar niveles de logs
	if (verboseLevel==0)
		LOG_LEVEL(LOG_ERR);
	else if (verboseLevel==1)
		LOG_LEVEL(LOG_NOTICE);
	else
		LOG_LEVEL(LOG_DEBUG);
}

void die(char *msg) {
  LOG_E(msg);
  exit(EXIT_FAILURE);
}

void signalHandler(int signal) {

	switch (signal) {

	case SIGHUP:
		LOG_W("Hungup signal received. Do something interesting");
		//TODO: Do something interesting.
		break;
	case SIGTERM:
		LOG_W("Teminate signal received. Quitting");

		terminate = true;

		//exit(EXIT_SUCCESS);
		break;

	}
}



int sendAck(int sckt, long serialNumber,struct sockaddr *addTo, socklen_t toLen ) {
	int result = false;
	unsigned char buf[TRANS_MAX_BUFF_SIZE];
	frm_cmd_ack_t ack;
	size_t len = sizeof(ack);


	if ( frame_encode_ack(serialNumber,0,&ack,&len)){
		len =sizeof(buf);
		if (frame_encode_transport(0,&ack,sizeof(ack),buf,&len )) {
			sendto(sckt,buf,len,0,addTo,toLen);
			result = true;
		}
	}

	return result;
}

int sendAckOld(int sckt, long serialNumber,struct sockaddr *addTo, socklen_t toLen ) {
	int result = false;

	unsigned char ackOld[]={0xEF,0x00,0x00,0x00,0xEF};

	sendto(sckt,ackOld,sizeof(ackOld),0,addTo,toLen);

	result = true;

    return result;
}

//Very quick & dirty UDP Server
//TODO: Improving performance using  select()/poll()  and maybe multiprocess or multithreading.

int runUDPserver() {

	int sckt;
	int n;
	socklen_t fromLen;
	struct sockaddr_in server, from;

	hashint_table_t ht;
	time_t *lastTime;

	time_t lastCheck;



	char buf[TRANS_MAX_BUFF_SIZE];
	DB_T *db;

	LOG_D("Iniciando servidor UDP");

	memset(buf,0,sizeof(buf));

	LOG_D("Creando socket");
	sckt = socket(AF_INET,SOCK_DGRAM,0);

	if (sckt<0) {

		LOG_E(strerror(errno));

		return EXIT_FAILURE;
	}

	memset(&server,0,sizeof(server));

    server.sin_family= AF_INET;
    server.sin_port=htons(udpPort);
    server.sin_addr.s_addr=htonl(INADDR_ANY);

	LOG_D("Bindando socket");

    if (bind(sckt,(struct sockaddr *)&server,sizeof(server))<0) {

	   LOG_E(strerror(errno));

	   return EXIT_FAILURE;

    }

    LOG_F_N("Server listening on port %u",udpPort);

    ht = hashint_table_create(0);



	fromLen = sizeof(from);

	db = db_create("localhost","Yii","user","entrar");

	if (!db_connect(db)) {
		die("Error connecting database");
	}

	lastCheck = time(NULL);

	//TODO: select()/poll()

	while(!terminate) {  // loop until terminate

	   n = recvfrom(sckt,buf,TRANS_MAX_BUFF_SIZE,0,(struct sockaddr *)&from,&fromLen);

	   if (n<0) {
		   LOG_F_E("Error receiving data: %s",strerror(errno));
		   continue;
	   }

	   // De momento no señalizamos nada
	   //sendto(sckt,MSG_OK,sizeof(MSG_OK),0,(struct sockaddr *)&from,fromLen);
	   //

	   LOG_F_N("Incoming [%s:%u (%d)]",inet_ntoa(from.sin_addr),ntohs(from.sin_port),n);


	   if ( !(lastTime=hashint_table_get(ht,ntohl(from.sin_addr.s_addr)))){
		   lastTime = malloc(sizeof(time_t));
		   *lastTime =  0;  //time(NULL);  // Para que la primera si se asienta..
		   hashint_table_add(ht,ntohl(from.sin_addr.s_addr),lastTime);
	   }

	   transport_buf_p trans =(transport_buf_p) buf;

	   if (frame_test_transport(buf,n)) {

		   // Estoy sospechando que tras un tiempo la conexion con la bbdd se cierra....
		   if ((time(NULL)-lastCheck)>DB_TIMEOUT_SECS) {
			   LOG_D("Checking DB connection");

			   if (!db_chkConnection(db)) {
				   LOG_E("Database connection appears to be closed. Trying to reconnect");
				   db_disconnect(db);
				   db_connect(db);
			   }

			   lastCheck =time(NULL);
		   }

		   // Ahora sólo guaradamos la carga util . El resto se guarda como campos de la tabla
		   mydb_insert_transport_frame(db,ntohl(from.sin_addr.s_addr),ntohs(from.sin_port),ntohl(trans->header.sn),buf+TRANS_PREAMBLE_SIZE,n-TRANS_OVERLOAD);

		   // TODO Esto hay que cambiarlo;
		   // Mandar ACKs
		   int size = n-TRANS_OVERLOAD;
		   size_t len;
		   int offset = TRANS_PREAMBLE_SIZE;
		   long sn = ntohl(trans->header.sn);

		   len = size;
		   if (frame_test_gps(buf+offset,&len)) {
			   offset +=len;
			   size   -=len;

			   // TODO implementar una pequeña lista para solo enviar
			   // acks cada X tiempo

//			   lastTime = hashint_table_get(ht,ntohl(from.sin_addr.s_addr));
//
//			   if ( time(NULL)-(*lastTime)>120)
//				   sendAckOld(sckt,sn,(struct sockaddr *)&from,fromLen);
		   }

		   len = size;
		   if (frame_test_cnx(buf+offset,&len)) {
			   offset +=len;
			   size   -=len;

			  // sendAckOld(sckt,sn,(struct sockaddr *)&from,fromLen);
		   }


		   // Otros test;

		   // Mandamos un ack cada ACK_TIMEOUT_SECS segundos

		   lastTime = hashint_table_get(ht,ntohl(from.sin_addr.s_addr));

		   if ( time(NULL)-(*lastTime)>ACK_TIMEOUT_SECS) {
			   sendAckOld(sckt,sn,(struct sockaddr *)&from,fromLen);
			   *lastTime = time(NULL);
		   }

	   }
	   else {
		   LOG_E("Incorrect Transport Frame!");

		   // En este caso grabamos todo para depuracion
		   mydb_insert_trashed_transport_frame(db,ntohl(from.sin_addr.s_addr),ntohs(from.sin_port),ntohl(trans->header.sn),buf,n);

	   }

	   //*lastTime = time(NULL);


	}

	close(sckt);
	hashint_table_destroy(&ht,true);
	db_destroy(db);

	return EXIT_SUCCESS;
}


int runUpdServer_mysql() {

}

void doOldGpsFrameTest() {
	unsigned char buf[] = {0x00,0x00,0x17,0x01,0x02,0x03,0x04,0x11,0x00,0x00,0x00,0x01,0x2a,0x33,0x90,0x08,0x98,0x58,0x91,0x3c,0x8C,0x51,0xFA,0x32,0x41,0xAC}; //BB

		unsigned char ogps[]= {0x00,0x00,0x1A,0x01,0x02,0x03,0x04,0x13,0x11,0x00,0x01,0x00,0x00,0xAA,0x86,0xEF,0x72,0x01,0xA8,0x58,0x9A,0x8B,0x29,0x05,0x4A,0x8D,0x27,0x3E,0xA4};
		// 09/08/2013 12:33:46	41,48642	-5,718267	11	1	1	48	1	0	1	1	7	Zamora	CL-605	ZAMORA	1	0	1	3	39 = 0x27	1

		frm_cmd_gps_t gps;
		frm_cmd_gps_p pgps;

		transport_buf_p trans;

		time_t epoch;

		char strTime[50];

		unsigned char chkSum=0;


	    if (frame_test_transport(ogps,sizeof(ogps))) {

	    	struct tm *ptime;

	    	trans = (transport_buf_p) ogps;
	    	frm_cmd_gps_old_p opgps = (frm_cmd_gps_old_p) trans->data;

	    	epoch= time(NULL);
	    	ptime = gmtime(&epoch);

	    	printf("Old Gps size = " ,sizeof(frm_cmd_gps_old_t));

	    	opgps->info.data.asWord = ntohs(opgps->info.data.asWord);

	    	printf("Datos trama Gps:\n"
	    			    "\tCMD: 0x%02x\n"
	    				"\tLEN: %d\n"
	    			    "\tSEQ_L: 0x%04X\n"
	    			    "\tSEQ_S: 0x%04X\n"
	    				"\tLAT: %.4f\n"
	    				"\tLON: %.4f\n"
	    				"\tBEAR: %d\n"
	    				"\tFIX: %d\n"
	    				"\tHDOP: %d\n"
	    				"\tKNOTS: %d\n"
	    				"\tSPEED: %.3f kmph\n"
	    				"\tExten. %d \n"
	    				"\tSize: %d \n"
	    			 	"\tIgnition: %d\n"
	    			    "\tTurnon: %d\n"
	    				"\tTIME: %04d-%02d-%02d %02d:%02d:%02d UTC\n"
	    			    "\n"
	    				,opgps->cmd
	    				,opgps->len
	    				,ntohs(opgps->seq_l)
	    				,ntohs(opgps->seq_s)
	    				,GPS_DECODE_LOC(opgps->info.lat_sign,opgps->info.lat_deg,ntohs(opgps->info.lat_min))
	    				,GPS_DECODE_LOC(opgps->info.data.parts.lon_sign,opgps->info.lon_deg,ntohs(opgps->info.lon_min))
	    				,GPS_DECODE_OLD_BEARING(opgps->info.data.parts.bear2,opgps->info.bear1,opgps->info.bear0)
	    				,opgps->info.data.parts.fix
	    				,opgps->info.hdop
	    				,opgps->info.knots
	    				,GPS_DECODE_SPEED(opgps->info.knots)
	    				,opgps->info.ext
	    				,opgps->info.size
	    				,opgps->info.data.parts.ign
	    				,opgps->info.turnon
	    				,((ptime->tm_year+1900) & ~0x3) | opgps->info.year
	    				,opgps->info.month
	    				,opgps->info.day
	    				,opgps->info.hour
	    				,opgps->info.data.parts.mins
	    				,opgps->info.data.parts.secs
	    				);

	    }



		trans = (transport_buf_p) buf;

		printf("Buff size = " ,sizeof(buf));

		printf("Transport Size 0x%08X 0x%08X %d\n",trans->header.length,ntohs(trans->header.length),ntohs(trans->header.length));



		int dataLen = ntohs(trans->header.length);

		/*
			for (int i=0; i< dataLen-1 ;i++) {
			   chkSum ^= buf[TRANS_HEADER_SIZE+i];
			}
	    */

		DB_T *db = db_create("localhost","Yii","user","entrar");
		if (!db_connect(db)) {
			die("Error connecting database");
		}

		if ( frame_test_transport(buf,sizeof(buf)) ) {

			printf("Transport check ok\n");
			mydb_insert_transport_frame(db,0,0,0,buf,sizeof(buf));


			frm_cmd_gps_t gps;
			size_t gpsLen = sizeof(gps);

			if (frame_decode_gps(buf+TRANS_DATA_OFFSET,dataLen-TRANS_HEADER_SERIAL_SIZE,&gps,&gpsLen)) {

				mydb_insert_gps_subframe(db,1,1,&gps,gpsLen);

			}

		}

		//db_disconnect(db);
		db_destroy(db);

		printf("Datos transporte:\n"
				"\tStart\n"
				"\t\tLit. Endian: %d\n"
				"\t\tCRC : %d\n"
				"\t\tVersion: %d\n"
				"\t\tSerial: 0x%08X\n"
				"\t\tLength: %d\n"
				"\t\tChkSum:  0x%02X\n"
				"\t\tChkSum2: 0x%02X\n"
				"\t\tVerSum:  0x%02X\n"
				, trans->header.start.lendian
				, trans->header.start.crc
				, trans->header.start.version
				, ntohl(trans->header.sn)
				, ntohs(trans->header.length)
				, trans->data[ntohs(trans->header.length)-TRANS_HEADER_SERIAL_SIZE-1]
				, buf[TRANS_HEADER_SIZE+dataLen-1]
				, chkSum
				);


		printf("\nData: ");
		for (int i=0; i< dataLen; i++) {

			printf(" %02X",trans->data[i]);
		}
	    printf("\n");


		printf("Transport SN 0x%08X 0x%08X \n",trans->header.sn,ntohl(trans->header.sn));

	    printf("Sizeof gps Struct = %u\n",sizeof(gps));

		pgps = (frm_cmd_gps_p) trans->data;

		epoch = ntohl(pgps->time.epoch);

		strftime(strTime,sizeof(strTime),"%F %T",gmtime(&epoch));

		printf("Datos trama Gps:\n"
			    "\tCMD: 0x%02x\n"
			    "\tSEQ: 0x%08X\n"
				"\tLAT: %.4f\n"
				"\tLON: %.4f\n"
				"\tBEAR: %d\n"
				"\tFIX: %d\n"
				"\tHDOP: %d\n"
				"\tKNOTS: %d\n"
				"\tSPEED: %.3f kmph\n"
				"\tTIME: %d %s\n"
			    "\n"
				,pgps->cmd
				,ntohs(pgps->seq_l)
				,GPS_DECODE_LOC(pgps->lat_sign,pgps->lat_deg,ntohs(pgps->lat_min))
				,GPS_DECODE_LOC(pgps->lon_sign,pgps->lon_deg,ntohs(pgps->lon_min))
				,GPS_DECODE_BEARING(pgps->bearing)
				,pgps->fix
				,pgps->hdop
				,pgps->knots
				,GPS_DECODE_SPEED(pgps->knots)
				,ntohl(pgps->time.epoch)
				,strTime
				);

		die("End of test");
}

void testPrintOldGpsInfo(frm_gps_old_p pgps) {


	struct tm *ptime;
	struct tm tp;

	time_t epoch = time(NULL);
	time_t myTime;

   	ptime = gmtime(&epoch);

   	pgps->data.asWord = ntohs(pgps->data.asWord);

   	memset(&tp,0,sizeof(tp));



   	tp.tm_year = (ptime->tm_year & ~0x03) | pgps->year;
   	tp.tm_mon  = pgps->month-1;
   	tp.tm_mday = pgps->day;
   	tp.tm_hour = pgps->hour;
   	tp.tm_min  = pgps->data.parts.mins;
   	tp.tm_sec  = pgps->data.parts.secs;
   	myTime = timegm(&tp);

	printf("Datos trama Old Gps:\n"
			"\tDATE: %04d-%02d-%02d\n"
			"\tTIME: %02d:%02d:%02d\n"
			"\tLAT:  %.6f\n"
			"\tLON:  %.6f\n"
			"\tLATR: %.7f\n"
			"\tLONR: %.7f\n"
			"\tBEAR: %d\n"
			"\tFIX: %d\n"
			"\tHDOP: %d\n"
			"\tKNOTS: %d\n"
			"\tSPEED: %.3f kmph\n"
			"\tEPOCH: %d\n"
		    "\n"
			,((ptime->tm_year+1900) & ~0x3) | pgps->year, pgps->month,pgps->day
			,pgps->hour,pgps->data.parts.mins,pgps->data.parts.secs
			,GPS_DECODE_LOC(pgps->lat_sign,pgps->lat_deg,ntohs(pgps->lat_min))
			,GPS_DECODE_LOC(pgps->data.parts.lon_sign ,pgps->lon_deg,ntohs(pgps->lon_min))
			,GPS_DECODE_LOC(pgps->lat_sign,pgps->lat_deg,ntohs(pgps->lat_min))
			,GPS_DECODE_LOC(pgps->data.parts.lon_sign ,pgps->lon_deg,ntohs(pgps->lon_min))
			,GPS_DECODE_OLD_BEARING(pgps->data.parts.bear2,pgps->bear1,pgps->bear0)
			,pgps->data.parts.fix
			,pgps->hdop
			,pgps->knots
			,GPS_DECODE_SPEED(pgps->knots)
			,myTime
		);

}

void doFrame015Test() {

	//unsigned char buff[] = {0x15,0x01,0x83,0x17,0x15,0x00,0x00,0x2A,0x14,0x79,0x22,0x72,0xC1,0x16,0x80,0xC2,0x2A,0x08,0x72,0xA0,0x0A,0x14,0x89,0x22,0x72,0xC1,0x16,0x80,0xC2,0x0A,0x14,0x99,0x22,0x72,0xC1,0x16,0x00,0x2E,0x0A,0x14,0xA9,0x22,0x71,0xC1,0x16,0x00,0x60,0x0A,0x14,0xB9,0x22,0x71,0xC1,0x16,0x00,0x37,0x0A,0x14,0xC9,0x22,0x71,0xC1,0x16,0x00,0x05,0x0A,0x14,0xD9,0x22,0x70,0xC1,0x16,0x00,0x43,0x0A,0x14,0xE9,0x22,0x70,0xC1,0x16,0x00,0x39,0x0A,0x14,0xF9,0x22,0x70,0xC1,0x16,0x00,0x26,0x0A,0x15,0x09,0x22,0x70,0xC1,0x16,0x00,0x9D,0x0A,0x15,0x19,0x22,0x6F,0xC1,0x17,0x01,0xBE,0x0A,0x15,0x29,0x22,0x6F,0xC1,0x17,0x00,0x8F,0x0A,0x15,0x39,0x22,0x6E,0xC1,0x17,0x00,0xBA,0x0A,0x15,0x49,0x22,0x6E,0xC1,0x17,0x00,0x93,0x0A,0x15,0x59,0x22,0x6D,0xC1,0x17,0x00,0xBB,0x0A,0x15,0x69,0x22,0x6D,0xC1,0x17,0x00,0x93,0x0A,0x15,0x79,0x22,0x6C,0xC1,0x17,0x00,0xD8,0x0A,0x15,0x89,0x22,0x6C,0xC1,0x17,0x00,0xD6,0x0A,0x15,0x99,0x22,0x6C,0xC1,0x17,0x00,0xCD,0x0A,0x15,0xA9,0x22,0x6C,0xC1,0x17,0x80,0x4D,0x0A,0x15,0xB9,0x22,0x6C,0xC1,0x18,0x00,0x80,0x0A,0x15,0xC9,0x22,0x6B,0xC1,0x18,0x00,0xD1,0x0A,0x15,0xD9,0x22,0x6B,0xC1,0x18,0x00,0xBD,0x0A,0x15,0xE9,0x22,0x6B,0xC1,0x18,0x00,0x9F,0x0A,0x15,0xF9,0x22,0x6B,0xC1,0x18,0x00,0x8B,0x0A,0x16,0x09,0x22,0x6B,0xC1,0x18,0x00,0x8B,0x0A,0x16,0x19,0x22,0x6B,0xC1,0x17,0x00,0x93,0x0A,0x16,0x29,0x22,0x6B,0xC1,0x18,0x00,0x8A,0x0A,0x16,0x39,0x22,0x6B,0xC1,0x18,0x00,0x8A,0x0A,0x16,0x49,0x22,0x6B,0xC1,0x18,0x00,0x80,0x0A,0x16,0x59,0x22,0x6B,0xC1,0x17,0x00,0x89,0x0A,0x16,0x69,0x22,0x6B,0xC1,0x17,0x00,0x88,0x0A,0x16,0x79,0x22,0x6B,0xC1,0x17,0x00,0x93,0x0A,0x16,0x89,0x22,0x6B,0xC1,0x17,0x00,0x9D,0x0A,0x16,0x99,0x22,0x6B,0xC1,0x17,0x00,0x9C,0x0A,0x16,0xA9,0x22,0x6B,0xC1,0x17,0x00,0xA5,0x0A,0x16,0xB1,0x22,0x6B,0xC1,0x17,0x00,0xA4,0x0A,0x16,0xC1,0x22,0x6B,0xC1,0x17,0x00,0x91,0x0A,0x16,0xD1,0x22,0x6A,0xC1,0x17,0x00,0xD9,0x0A,0x16,0xE9,0x22,0x6A,0xC1,0x18,0x80,0xD3,0x0A,0x16,0xF9,0x22,0x6A,0xC1,0x18,0x80,0xD6,0x0A,0x17,0x09,0x22,0x6A,0xC1,0x18,0x80,0xC4,0xFF};
    //unsigned char buff[] = {0x15,0x01,0x83,0x01,0x68,0x00,0x00,0x2C,0x24,0xC1,0x21,0xFA,0xC1,0x11,0x01,0xBF,0x2A,0x08,0x52,0xA0,0x0C,0x24,0xD1,0x21,0xFA,0xC1,0x11,0x01,0xE1,0x0C,0x24,0xE1,0x21,0xFB,0xC1,0x11,0x01,0xB1,0x0C,0x24,0xF1,0x21,0xFB,0xC1,0x12,0x00,0xD4,0x0C,0x25,0x01,0x21,0xFB,0xC1,0x12,0x00,0xE1,0x0C,0x25,0x11,0x21,0xFC,0xC1,0x13,0x00,0x8B,0x0C,0x25,0x21,0x21,0xFC,0xC1,0x13,0x00,0xB8,0x0C,0x25,0x31,0x21,0xFC,0xC1,0x14,0x00,0xB3,0x0C,0x25,0x41,0x21,0xFC,0xC1,0x14,0x00,0xC2,0x0C,0x25,0x51,0x21,0xFC,0xC1,0x14,0x00,0xC5,0x0C,0x25,0x61,0x21,0xFC,0xC1,0x14,0x00,0xBB,0x0C,0x25,0x71,0x21,0xFC,0xC1,0x14,0x00,0xA5,0x0C,0x25,0x81,0x21,0xFC,0xC1,0x14,0x00,0xA6,0x0C,0x25,0x91,0x21,0xFC,0xC1,0x15,0x00,0x9F,0x0C,0x25,0xA1,0x21,0xFC,0xC1,0x15,0x00,0xB5,0x0C,0x25,0xB1,0x21,0xFC,0xC1,0x15,0x00,0xC1,0x0C,0x25,0xC1,0x21,0xFC,0xC1,0x15,0x00,0xC3,0x0C,0x25,0xD1,0x21,0xFC,0xC1,0x16,0x00,0xC6,0x0C,0x25,0xE1,0x21,0xFC,0xC1,0x16,0x00,0xBD,0x0C,0x25,0xF1,0x21,0xFC,0xC1,0x16,0x00,0xC7,0x0C,0x26,0x01,0x21,0xFC,0xC1,0x16,0x00,0xD1,0x0C,0x26,0x11,0x21,0xFC,0xC1,0x16,0x00,0xD1,0x0C,0x26,0x21,0x21,0xFC,0xC1,0x16,0x00,0xD0,0x0C,0x26,0x31,0x21,0xFC,0xC1,0x16,0x00,0xD0,0x0C,0x26,0x41,0x21,0xFC,0xC1,0x16,0x00,0xD0,0x0C,0x26,0x51,0x21,0xFC,0xC1,0x15,0x00,0xD9,0x0C,0x26,0x61,0x21,0xFC,0xC1,0x15,0x00,0xD8,0x0C,0x26,0x71,0x21,0xFC,0xC1,0x15,0x00,0xCD,0x0C,0x26,0x81,0x21,0xFC,0xC1,0x15,0x00,0xCC,0x0C,0x26,0x91,0x21,0xFC,0xC1,0x15,0x00,0xB7,0x0C,0x26,0xA1,0x21,0xFC,0xC1,0x15,0x80,0xAB,0x0C,0x26,0xB1,0x21,0xFC,0xC1,0x15,0x80,0x82,0x0C,0x26,0xC1,0x21,0xFB,0xC1,0x15,0x80,0xC9,0x0C,0x26,0xD1,0x21,0xFB,0xC1,0x15,0x80,0x90,0x0C,0x26,0xE1,0x21,0xFA,0xC1,0x15,0x80,0xC0,0x0C,0x26,0xF1,0x21,0xFA,0xC1,0x15,0x80,0xA0,0x0C,0x27,0x01,0x21,0xF9,0xC1,0x15,0x80,0xDC,0x0C,0x27,0x11,0x21,0xF9,0xC1,0x15,0x80,0xC7,0x0C,0x27,0x21,0x21,0xF8,0xC1,0x14,0x80,0xC0,0x0C,0x27,0x31,0x21,0xF8,0xC1,0x13,0x80,0x8F,0x0C,0x27,0x41,0x21,0xF8,0xC1,0x12,0x80,0x92,0x0C,0x27,0x51,0x21,0xF7,0xC1,0x11,0x80,0xBA,0xFF};
    //unsigned char buff[] = {0x15,0x01,0x83,0x3D,0xF7,0x00,0x00,0x2A,0x18,0xE9,0x31,0xCC,0xAB,0xBA,0x81,0x2E,0x2A,0x08,0x4A,0xB0,0x0A,0x18,0xF9,0x31,0xCC,0xAB,0xBA,0x81,0x34,0x0A,0x19,0x09,0x31,0xCC,0xAB,0xB9,0x81,0x4D,0x0A,0x19,0x19,0x31,0xCC,0xAB,0xB9,0x81,0x53,0x0A,0x19,0x29,0x31,0xCD,0xAB,0xB8,0x81,0x09,0x0A,0x19,0x39,0x31,0xCD,0xAB,0xB8,0x81,0x0E,0x0A,0x19,0x49,0x31,0xCD,0xAB,0xB8,0x81,0x14,0x0A,0x19,0x59,0x31,0xCD,0xAB,0xB7,0x81,0x25,0x0A,0x19,0x69,0x31,0xCD,0xAB,0xB7,0x81,0x2B,0x0A,0x19,0x79,0x31,0xCD,0xAB,0xB6,0x81,0x3B,0x0A,0x19,0x89,0x31,0xCD,0xAB,0xB6,0x81,0x42,0x0A,0x19,0x99,0x31,0xCD,0xAB,0xB6,0x80,0x48,0x0A,0x19,0xA9,0x31,0xCD,0xAB,0xB5,0x80,0x59,0x0A,0x19,0xB9,0x31,0xCD,0xAB,0xB5,0x81,0x60,0x0A,0x19,0xC9,0x31,0xCE,0xAB,0xB5,0x80,0x02,0x0A,0x19,0xD9,0x31,0xCE,0xAB,0xB4,0x80,0x09,0x0A,0x19,0xE9,0x31,0xCE,0xAB,0xB4,0x80,0x06,0x0A,0x19,0xF9,0x31,0xCE,0xAB,0xB4,0x80,0x05,0x0A,0x1A,0x09,0x31,0xCE,0xAB,0xB4,0x80,0x04,0x0A,0x1A,0x19,0x31,0xCD,0xAB,0xB4,0x80,0x5D,0x0A,0x1A,0x29,0x31,0xCD,0xAB,0xB4,0x80,0x5C,0x0A,0x1A,0x39,0x31,0xCD,0xAB,0xB4,0x80,0x5A,0x0A,0x1A,0x49,0x31,0xCD,0xAB,0xB3,0x80,0x63,0x0A,0x1A,0x59,0x31,0xCD,0xAB,0xB3,0x80,0x62,0x0A,0x1A,0x69,0x31,0xCE,0xAB,0xB3,0x80,0x06,0x0A,0x1A,0x79,0x31,0xCE,0xAB,0xB3,0x80,0x05,0x0A,0x1A,0x89,0x31,0xCE,0xAB,0xB3,0x80,0x0D,0x0A,0x1A,0x99,0x31,0xCE,0xAB,0xB3,0x80,0x16,0x0A,0x1A,0xA9,0x31,0xCE,0xAB,0xB3,0x80,0x1F,0x0A,0x1A,0xB9,0x31,0xCE,0xAB,0xB2,0x80,0x26,0x0A,0x1A,0xC9,0x31,0xCE,0xAB,0xB2,0x80,0x2E,0x0A,0x1A,0xD9,0x31,0xCE,0xAB,0xB2,0x80,0x37,0x0A,0x1A,0xE9,0x31,0xCE,0xAB,0xB2,0x80,0x35,0x0A,0x1A,0xF9,0x31,0xCE,0xAB,0xB2,0x80,0x3E,0x0A,0x1B,0x09,0x31,0xCE,0xAB,0xB2,0x80,0x3C,0x0A,0x1B,0x19,0x31,0xCE,0xAB,0xB1,0x80,0x4D,0x0A,0x1B,0x29,0x31,0xCE,0xAB,0xB1,0x80,0x4B,0x0A,0x1B,0x39,0x31,0xCE,0xAB,0xB1,0x80,0x49,0x0A,0x1B,0x49,0x31,0xCE,0xAB,0xB1,0x80,0x48,0x0A,0x1B,0x59,0x31,0xCE,0xAB,0xB1,0x80,0x46,0x0A,0x1B,0x69,0x31,0xCE,0xAB,0xB0,0x80,0x44,0x0A,0x1B,0x79,0x31,0xCE,0xAB,0xB0,0x80,0x42,0xFF};
    //unsigned char buff[] = {0x15,0x01,0x83,0x3D,0xED,0x00,0x00,0x29,0xEC,0xF1,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x4A,0xB0,0x09,0xED,0x01,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xED,0x11,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xED,0x21,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xED,0x31,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xED,0x41,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xED,0x51,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xED,0x61,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xED,0x71,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xED,0x81,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xED,0x91,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xED,0xA1,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xED,0xB1,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xED,0xC1,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xED,0xD1,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xED,0xE1,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xED,0xF1,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xEE,0x01,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xEE,0x11,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xEE,0x21,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xEE,0x31,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xEE,0x41,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xEE,0x51,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xEE,0x61,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xEE,0x71,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xEE,0x81,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xEE,0x91,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xEE,0xA1,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xEE,0xB1,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xEE,0xC1,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xEE,0xD1,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xEE,0xE1,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xEE,0xF1,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xEF,0x01,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xEF,0x11,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xEF,0x21,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xEF,0x31,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xEF,0x41,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xEF,0x51,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xEF,0x61,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xEF,0x71,0x00,0x00,0x00,0x00,0x80,0x00,0x09,0xEF,0x81,0x00,0x00,0x00,0x00,0x80,0x00,0xFF};
    //unsigned char buff[] = {0x15,0x01,0x83,0x3F,0x42,0x00,0x00,0x27,0xD6,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x72,0xB0,0x07,0xD6,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD6,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD6,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD6,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD6,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD6,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD6,0x90,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD6,0xA0,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD6,0xB0,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD6,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD6,0xD0,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD6,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD6,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD7,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD7,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD7,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD7,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD7,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD7,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD7,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD7,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD7,0x90,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD7,0xA0,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD7,0xB0,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD8,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD8,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD8,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD8,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD8,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD8,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD8,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD8,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD8,0x90,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD8,0xA0,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD8,0xB0,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD8,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD8,0xD0,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD8,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xD8,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0xFF};
	//unsigned char buff[] = {0x15,0x01,0x83,0x3E,0xCA,0x00,0x00,0x2C,0xB4,0x69,0x1A,0xD9,0xBB,0x72,0x8F,0x02,0x2A,0x08,0x4A,0xB0,0x0C,0xB4,0x79,0x1A,0xD9,0xBB,0x77,0x8F,0x44,0x0C,0xB4,0x89,0x1A,0xDA,0xBB,0x7D,0x8E,0x0D,0x0C,0xB4,0x99,0x1A,0xDA,0xBB,0x82,0x8E,0x56,0x0C,0xB4,0xA9,0x1A,0xDB,0xBB,0x88,0x8F,0x29,0x0C,0xB4,0xB9,0x1A,0xDC,0xBB,0x8D,0x8F,0x09,0x0C,0xB4,0xC9,0x1A,0xDC,0xBB,0x94,0x90,0x3C,0x0C,0xB4,0xD9,0x1A,0xDD,0xBB,0x9A,0x91,0x22,0x0C,0xB4,0xE9,0x1A,0xDE,0xBB,0xA1,0x92,0x0D,0x0C,0xB4,0xF9,0x1A,0xDE,0xBB,0xA8,0x94,0x61,0x0C,0xB5,0x09,0x1A,0xDF,0xBB,0xB0,0x95,0x4D,0x0C,0xB5,0x19,0x1A,0xE0,0xBB,0xB9,0x96,0x3E,0x0C,0xB5,0x29,0x1A,0xE1,0xBB,0xC1,0x97,0x26,0x0C,0xB5,0x39,0x1A,0xE2,0xBB,0xCA,0x97,0x0E,0x0C,0xB5,0x49,0x1A,0xE3,0xBB,0xD3,0x98,0x04,0x0C,0xB5,0x59,0x1A,0xE4,0xBB,0xDC,0x98,0x05,0x0C,0xB5,0x69,0x1A,0xE5,0xBB,0xE5,0x98,0x0F,0x0C,0xB5,0x79,0x1A,0xE6,0xBB,0xEE,0x98,0x1A,0x0C,0xB5,0x89,0x1A,0xE7,0xBB,0xF7,0x98,0x11,0x0C,0xB5,0x99,0x1A,0xE8,0xBC,0x00,0x99,0x1D,0x0C,0xB5,0xA9,0x1A,0xE9,0xBC,0x0A,0x99,0x0F,0x0C,0xB5,0xB9,0x1A,0xEA,0xBC,0x14,0x9A,0x02,0x0C,0xB5,0xC9,0x1A,0xEA,0xBC,0x1E,0x9A,0x5B,0x0C,0xB5,0xD9,0x1A,0xEB,0xBC,0x28,0x9A,0x51,0x0C,0xB5,0xE9,0x1A,0xEC,0xBC,0x32,0x9B,0x5C,0x0C,0xB5,0xF9,0x1A,0xEE,0xBC,0x3C,0x9B,0x0E,0x0C,0xB6,0x09,0x1A,0xEF,0xBC,0x46,0x9B,0x1B,0x0C,0xB6,0x19,0x1A,0xF0,0xBC,0x51,0x9B,0x1E,0x0C,0xB6,0x29,0x1A,0xF1,0xBC,0x5B,0x9B,0x2D,0x0C,0xB6,0x39,0x1A,0xF2,0xBC,0x66,0x9C,0x28,0x0C,0xB6,0x49,0x1A,0xF2,0xBC,0x70,0x9B,0x5F,0x0C,0xB6,0x59,0x1A,0xF3,0xBC,0x7B,0x9B,0x00,0x0C,0xB6,0x69,0x1A,0xF2,0xBC,0x85,0x9B,0x49,0x0C,0xB6,0x79,0x1A,0xF1,0xBC,0x8F,0x9B,0x60,0x0C,0xB6,0x89,0x1A,0xF0,0xBC,0x99,0x9B,0x30,0x0C,0xB6,0x99,0x1A,0xEE,0xBC,0xA3,0x9B,0x4F,0x0C,0xB6,0xA9,0x1A,0xEC,0xBC,0xAD,0x9B,0x4F,0x0C,0xB6,0xB9,0x1A,0xEA,0xBC,0xB7,0x9B,0x59,0x0C,0xB6,0xC9,0x1A,0xE9,0xBC,0xC2,0x9B,0x15,0x0C,0xB6,0xD9,0x1A,0xE7,0xBC,0xCC,0x9B,0x54,0x0C,0xB6,0xE9,0x1A,0xE6,0xBC,0xD6,0x9A,0x53,0x0C,0xB6,0xF9,0x1A,0xE6,0xBC,0xE0,0x9A,0x02,0xFF};
	unsigned char buff[] = {0x15,0x01,0x83,0x3F,0xAA,0x00,0x00,0x30,0x4F,0x79,0x22,0x00,0xC1,0x2C,0x80,0x31,0x2A,0x08,0x72,0xB0,0x10,0x4F,0x89,0x22,0x00,0xC1,0x2C,0x80,0x27,0x10,0x4F,0x99,0x22,0x00,0xC1,0x2C,0x00,0x12,0x10,0x4F,0xA9,0x22,0x00,0xC1,0x2C,0x00,0x31,0x10,0x4F,0xB9,0x22,0x00,0xC1,0x2C,0x00,0x3B,0x10,0x50,0x09,0x22,0x00,0xC1,0x2D,0x00,0x32,0x10,0x50,0x19,0x22,0x00,0xC1,0x2D,0x00,0x46,0x10,0x50,0x29,0x22,0x00,0xC1,0x2C,0x00,0x45,0x10,0x50,0x39,0x22,0x00,0xC1,0x2C,0x00,0x3B,0x10,0x50,0x49,0x22,0x00,0xC1,0x2C,0x00,0x31,0x10,0x50,0x59,0x22,0x00,0xC1,0x2C,0x00,0x27,0x10,0x50,0x69,0x22,0x00,0xC1,0x2C,0x00,0x12,0x10,0x50,0x79,0x22,0x00,0xC1,0x2C,0x00,0x08,0x10,0x50,0x89,0x21,0xFF,0xC1,0x2C,0x00,0x62,0x10,0x50,0x99,0x21,0xFF,0xC1,0x2C,0x00,0x58,0x10,0x50,0xA9,0x21,0xFF,0xC1,0x2C,0x00,0x4D,0x10,0x50,0xB9,0x21,0xFF,0xC1,0x2C,0x00,0x4C,0x10,0x50,0xC9,0x21,0xFF,0xC1,0x2C,0x00,0x4C,0x10,0x50,0xD9,0x21,0xFF,0xC1,0x2C,0x00,0x42,0x10,0x50,0xE9,0x21,0xFF,0xC1,0x2C,0x00,0x42,0x10,0x50,0xF9,0x21,0xFF,0xC1,0x2C,0x00,0x42,0x10,0x51,0x09,0x21,0xFF,0xC1,0x2C,0x00,0x43,0x10,0x51,0x19,0x21,0xFF,0xC1,0x2C,0x00,0x43,0x10,0x51,0x29,0x21,0xFF,0xC1,0x2C,0x00,0x43,0x10,0x51,0x39,0x21,0xFF,0xC1,0x2C,0x00,0x42,0x10,0x51,0x49,0x21,0xFF,0xC1,0x2C,0x00,0x42,0x10,0x51,0x59,0x21,0xFF,0xC1,0x2C,0x00,0x42,0x10,0x51,0x69,0x21,0xFF,0xC1,0x2C,0x00,0x38,0x10,0x51,0x79,0x21,0xFF,0xC1,0x2C,0x00,0x38,0x10,0x51,0x89,0x21,0xFF,0xC1,0x2C,0x00,0x2E,0x10,0x51,0x99,0x21,0xFF,0xC1,0x2C,0x00,0x2E,0x10,0x51,0xA9,0x21,0xFF,0xC1,0x2C,0x00,0x38,0x10,0x51,0xB9,0x21,0xFF,0xC1,0x2C,0x00,0x38,0x10,0x51,0xC9,0x21,0xFF,0xC1,0x2C,0x00,0x42,0x10,0x51,0xD9,0x21,0xFF,0xC1,0x2C,0x00,0x43,0x10,0x51,0xE9,0x21,0xFF,0xC1,0x2C,0x00,0x44,0x10,0x51,0xF9,0x21,0xFF,0xC1,0x2C,0x00,0x45,0x10,0x52,0x09,0x21,0xFF,0xC1,0x2C,0x00,0x45,0x10,0x52,0x19,0x21,0xFF,0xC1,0x2C,0x00,0x45,0x10,0x52,0x29,0x21,0xFF,0xC1,0x2D,0x00,0x46,0x10,0x52,0x39,0x21,0xFF,0xC1,0x2D,0x00,0x47,0x10,0x52,0x49,0x21,0xFF,0xC1,0x2D,0x00,0x48,0xFF};

	if (sizeof(buff) > sizeof(frm_cmd_gps_old_t) ) {   //TODO Verificar los tamaños

		frm_cmd_rally_gps_old_p pCmd = (frm_cmd_rally_gps_old_p) buff;

		if( (pCmd->cmd == 0x15) && (ntohs(pCmd->len)>250)) {

			frm_gps_old_t cache;
			frm_gps_old_p pGps = &pCmd->info;
			bool init = false;
			bool extended = false;
			int offset = 0;

			while (pGps->hour<23) {

				extended = pGps -> ext;

				    /* "00" => 9 bytes
				       "01" => 13 bytes
				        "10" => 2 bytes y contacto=0
				        "11" => 2 bytes y contacto=1 y fix=0
				     */

				switch (pGps->size) {

				case 0: // 00

					memcpy(&cache,pGps,sizeof(cache)-4); // Todos los campos menos los 4 ultimos

					offset = sizeof(cache)-4;  // En teoria 9;

					break;

				case 1:  // 11
					init = true;

					cache = *pGps; // Copiamos todos los datos

					offset = sizeof(cache); // En teoria 13;

					break;

				case 2:

					cache.hour = pGps->hour;
					cache.data.parts.mins = pGps->data.parts.mins;
					cache.data.parts.ign = 0;

					offset = 2;
					break;

				case 3:
					cache.hour = pGps->hour;
					cache.data.parts.mins = pGps->data.parts.mins;
					cache.data.parts.ign = 1;
					cache.data.parts.fix = 0;

					offset = 2;

						break;

					}

					// Hacer algo con datos Gps

				if (!init) {
					//Sale en caso de que no haya venido una trama de 13 bytes primero
					printf("Error: Formato de trama incorrecto\n");
					break;
				}

				testPrintOldGpsInfo(&cache);


				if (extended) {
					// Hacer cositas con los datos extendidos

					// FIXME De momento no soportamos tramas extendidas.

					printf("Error: Trama extendida no soportado\n");
					break; //While
					//

				}


				// Se continua...
			   pGps =  ((char *) pGps) + offset;
				//((char *)pGps)+=offset;


			}


		}

	}


}

void doTestAndDie() {

	//doOldGpsFrameTest();


	doFrame015Test();

	die("End Tests");
}

int main(int argc, char **argv) {

	struct sigaction action;

	int exitCode;

	//doTestAndDie();

	parseArgs(argc,argv);
	initLogs();

	if (keepAsDaemon) {

		LOG_N("Trying to keep as a daemon...");

		if (daemon(false,false)<0) {
			LOG_E(strerror(errno));
			LOG_W("... continuing daemonless");

		} else {

			LOG_N("... Success ");
		}

	}

	memset(&action,0,sizeof(action));
	//	sigemptyset(&action.sa_mask);
	//	action.sa_flags = 0;
	action.sa_handler =signalHandler;


	sigaction(SIGHUP,&action,NULL);
	sigaction(SIGTERM,&action,NULL);

//	signal(SIGHUP,signalHandler); /* catch hangup signal */
//	signal(SIGTERM,signalHandler); /* catch kill signal */

	exitCode=runUDPserver();

	return exitCode;

	//return EXIT_SUCCESS;
}
